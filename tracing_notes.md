# Structlog Tracing with `userId` and `requestId`

This document explains the setup for enhancing application logs with request-specific identifiers (`requestId`) and user identifiers (`userId`) using `structlog` in this Django project.

## Overall Goal: Enhanced Log Context for Request Tracing

The primary goal is to enrich your application logs with request-specific identifiers (`requestId`) and user identifiers (`userId`). This allows you to:
*   **Trace a single request** through multiple log entries, even across different parts of your application.
*   **Identify all actions performed by a specific user** within your logs.
*   **Debug issues more effectively** by quickly correlating related log messages.

## The Process: Step-by-Step Implementation

1.  **Create a Custom Django Middleware (`LearningAPI/middleware.py`)**:
    *   **Purpose**: This middleware intercepts every incoming HTTP request to your Django application.
    *   **Mechanism**:
        *   For each request, it generates a unique `requestId` (using `uuid.uuid4()`).
        *   It attempts to extract the `userId` from the authenticated user (`request.user.id`). If no user is authenticated, it defaults to 'anonymous'.
        *   It also captures the request `path` and `method`.
        *   Crucially, it uses `structlog.contextvars.bind_contextvars` to attach these `request_id`, `user_id`, `path`, and `method` values to a thread-local context managed by `structlog`. This means any log message generated *during the processing of that request* will automatically include these bound variables.
        *   After the request is processed (either successfully or with an exception), `structlog.contextvars.clear_contextvars()` is called to clean up the context, preventing data leakage between requests.

    *   **File Content**:
        ```python
        import structlog
        import uuid
        from django.utils.deprecation import MiddlewareMixin

        class RequestContextMiddleware(MiddlewareMixin):
            def process_request(self, request):
                request_id = str(uuid.uuid4())
                user_id = getattr(request.user, 'id', 'anonymous') # Get user ID if authenticated

                structlog.contextvars.clear_contextvars()
                structlog.contextvars.bind_contextvars(
                    request_id=request_id,
                    user_id=user_id,
                    path=request.path,
                    method=request.method,
                )

            def process_response(self, request, response):
                structlog.contextvars.clear_contextvars()
                return response

            def process_exception(self, request, exception):
                structlog.contextvars.clear_contextvars()
        ```

2.  **Register the Middleware in `LearningPlatform/settings.py`**:
    *   **Purpose**: To activate our custom middleware so it runs for every request.
    *   **Mechanism**: The `LearningAPI.middleware.RequestContextMiddleware` is added to the `MIDDLEWARE` list in your Django settings. It is placed after `django.contrib.auth.middleware.AuthenticationMiddleware` to ensure `request.user` is populated.

    *   **`settings.py` Diff**:
        ```diff
        <<<<<<< SEARCH
        :start_line:116
        :end_line:116
        -------
            'django.contrib.auth.middleware.AuthenticationMiddleware',
        =======
            'django.contrib.auth.middleware.AuthenticationMiddleware',
            'LearningAPI.middleware.RequestContextMiddleware', # Added for structlog tracing
        >>>>>>> REPLACE
        ```

3.  **Configure `structlog` Processors in `LearningPlatform/settings.py`**:
    *   **Purpose**: To ensure that the `request_id`, `user_id`, `path`, and `method` variables bound by our middleware are actually included in the final log output.
    *   **Mechanism**: `structlog.contextvars.merge_contextvars` is added to the list of `structlog` processors. This processor takes all variables currently bound in the `structlog` context and merges them into the event dictionary before it's rendered to the log output.

    *   **`settings.py` Diff**:
        ```diff
        <<<<<<< SEARCH
        :start_line:286
        :end_line:286
        -------
                structlog.stdlib.filter_by_level,
        =======
                structlog.stdlib.filter_by_level,
                structlog.contextvars.merge_contextvars, # Merges context from middleware
        >>>>>>> REPLACE
        ```

## How You Will Use These Traces:

Once these changes are implemented, every log message generated by `structlog` within the context of an HTTP request will automatically include the following fields:

*   `request_id`: A unique identifier for that specific HTTP request.
*   `user_id`: The ID of the user making the request (or 'anonymous').
*   `path`: The URL path of the request.
*   `method`: The HTTP method of the request (e.g., GET, POST).

**Example Log Output (JSON format, assuming `JSONRenderer`):**

```json
{
    "event": "User accessed course details",
    "level": "info",
    "logger": "LearningAPI.views.course_view",
    "timestamp": "2025-10-10T19:02:33.915Z",
    "request_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "user_id": 123,
    "path": "/api/courses/1/",
    "method": "GET",
    "course_id": 1
}
```

**Mechanism for Usage:**

*   **Log Aggregation Systems**: If you're using a log aggregation system (like ELK stack, Splunk, Datadog, etc.), you can easily filter, search, and group logs by `request_id` or `user_id` to see the full lifecycle of a request or all activities of a user.
*   **Local Log Files**: Even with local log files, you can use `grep` or other command-line tools to search for a specific `request_id` or `user_id` to find all related log entries.

This setup provides a robust and automatic way to add crucial tracing information to your logs without needing to manually pass these identifiers to every log call.